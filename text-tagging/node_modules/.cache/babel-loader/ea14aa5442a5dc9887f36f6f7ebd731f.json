{"ast":null,"code":"import _classCallCheck from\"C:\\\\Users\\\\Yifat\\\\finalProject\\\\text-tagging\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";import _inherits from\"C:\\\\Users\\\\Yifat\\\\finalProject\\\\text-tagging\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";import _createSuper from\"C:\\\\Users\\\\Yifat\\\\finalProject\\\\text-tagging\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";import React,{Component}from\"react\";import{ContextMenu,MenuItem,ContextMenuTrigger}from\"react-contextmenu\";var taggedTextArea=/*#__PURE__*/function(_Component){_inherits(taggedTextArea,_Component);var _super=_createSuper(taggedTextArea);function taggedTextArea(){var _this;_classCallCheck(this,taggedTextArea);for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_super.call.apply(_super,[this].concat(args));_this.state={// Used to keep the text the user marked\npreHighlightedText:\"\",highlightedText:\"\",postHighlightedText:\"\",preHtmlFormatedText:[],isHighlightedTextTagged:false//isUpTodate: true,\n};_this.isSpecialChar=function(character){for(var i=0;i<_this.props.specialCharsList.length;i++){if(_this.props.specialCharsList[i]===character){return true;}}return false;};_this.setTags=function(){if(_this.props.fileContent===\"\"){return;}// Separate the text in to lines.\nvar text=_this.props.fileContent;var regexIsSpace=RegExp(\"\\n\");var lines=text.split(regexIsSpace);// Work on each line seperately.\n// Convert every line to a format that later will be converted,\n// to an html format.\nvar convertedLine=\"\";var convertedLines=[];var htmlFormLines=[];for(var index=0;index<lines.length;index++){convertedLine=_this.separateTaggedFromUntaggedText(lines[index]);convertedLines.push(convertedLine);htmlFormLines.push(_this.makeHtmlForm(index,convertedLine));}_this.state.preHtmlFormatedText=convertedLines;// Add a break after each line.\nvar htmlForm=/*#__PURE__*/React.createElement(React.Fragment,null,htmlFormLines.map(function(line,i){return/*#__PURE__*/React.createElement(\"span\",{key:i,id:i},line,/*#__PURE__*/React.createElement(\"br\",null));}),/*#__PURE__*/React.createElement(\"br\",null));return htmlForm;};_this.separateTaggedFromUntaggedText=function(text){var higlight=\"<[^<]+>\";var regexIstag=RegExp(higlight);var regexIsCloseTag=RegExp(\"</[^<]+>\");var formattedparts=[];// Seperates plain text from tags.\nvar parts=text.split(new RegExp(\"(\".concat(higlight,\")\"),\"gi\"));// Handle each part.\nfor(var index=0;index<parts.length;index++){// If the tag is a plain text.\n// (or a closing tag without an opening tag matches it).\nif(!regexIstag.test(parts[index])&&parts[index]!==\"\"||regexIsCloseTag.test(parts[index])){// Add the text to the proccesd text.\nformattedparts.push(parts[index]);}// If the tag is an open tag.\nelse if(regexIstag.test(parts[index])&&!regexIsCloseTag.test(parts[index])){// Create a regex that checks for the closer tag matches the current tag.\nvar currenttag=parts[index].substring(1,parts[index].length-1);var regexIsSearchedTag=RegExp(\"</\"+currenttag+\">\");// Search the closer tag matches the currnt tag.\nvar serchingIndex=index+1;while(!regexIsSearchedTag.test(parts[serchingIndex])&&serchingIndex<parts.length){serchingIndex++;}// If a matching closer tag was not found.\nif(serchingIndex>=parts.length){// Consider the tag as a plain text.\n// Add the text to the proccesd text.\nformattedparts.push(parts[index]);}// If a matching closer tag was found.\nelse{// Make a string contains all the plain text surrounded by the tag.\nvar currentTaggedText=\"\";for(var copyingIndex=index+1;copyingIndex<serchingIndex;copyingIndex++){currentTaggedText+=parts[copyingIndex];}// Add the text to the proccesd text, with a prefix that tells the tag name.\nformattedparts.push(\"%\"+currenttag+\"%\"+currentTaggedText);index=serchingIndex;}}}return formattedparts;};_this.makeHtmlForm=function(lineNumber,line){var regexIsTagged=RegExp(\"%.+%.+\");var htmlForm=/*#__PURE__*/React.createElement(React.Fragment,null,\" \",line.map(function(part,i){return/*#__PURE__*/React.createElement(\"span\",{key:lineNumber+\",\"+i,id:lineNumber+\",\"+i,style:regexIsTagged.test(part)?{fontWeight:\"bold\",backgroundColor:_this.props.tagsAndColors[part.split(\"%\")[1]]}:{}},part.split(\"%\").reverse()[0]);}));return htmlForm;};_this.addTag=function(event,data){if(_this.state.highlightedText===\"\"){return;}//this.state.isUpTodate = false;\nvar tagName=window.getSelection().anchorNode.parentElement.id;var text;if(tagName!==\"no_tag\"){text=_this.state.preHighlightedText+\"<\"+tagName+\">\"+_this.state.highlightedText+\"</\"+tagName+\">\"+_this.state.postHighlightedText;}else{text=_this.state.preHighlightedText+_this.state.highlightedText+_this.state.postHighlightedText;}_this.state.preHighlightedText=\"\";_this.state.higlight=\"\";_this.state.postHighlightedText=\"\";_this.props.updateFileContent(text);};_this.captureHighlightedText=function(event,data){if(isNaN(window.getSelection())){return;}var base=window.getSelection().baseOffset;var extent=window.getSelection().extentOffset;var formatedText=_this.state.preHtmlFormatedText;// Get the lines number and part number the highlited text is in.\nvar lineAndparagraph=window.getSelection().anchorNode.parentElement.id;lineAndparagraph=lineAndparagraph.split(\",\");var line=parseInt(lineAndparagraph[0]);var paragraph=parseInt(lineAndparagraph[1]);// If the highlighted text is not valid.\nif(isNaN(line)||isNaN(paragraph)){return;}var borders=_this.calcBordersOfHighlightedText(base,extent);borders=_this.extendHighlightToEntireWord(formatedText,line,paragraph,borders[0],borders[1]);var offset=_this.clacOfsetFromTheStartOfTheText(formatedText,line,paragraph);borders[0]+=offset;borders[1]+=offset;_this.setPreInAndAfterHighlightedText(formatedText,line,paragraph,borders,offset);};_this.calcBordersOfHighlightedText=function(base,extent){var leftBorder;var rightBorder;if(base<=extent){leftBorder=base;rightBorder=extent;}else if(base>extent){leftBorder=extent;rightBorder=base;}return[leftBorder,rightBorder];};_this.extendHighlightToEntireWord=function(text,line,paragraph,leftIndex,rightIndex){var textParagraph=text[line][paragraph];// Sreaching for the begining of the highlighted word.\nvar begining;// If the first chracter is in a begining of a chunk.\nif(leftIndex===0){begining=leftIndex;}else{for(var index=leftIndex;index>=0;index--){// we reached the begining of the current paragraph.\nif(index===0){begining=index;// If we reached a space character.\n}else{var previousChar=textParagraph[index-1];//(!(previousChar.match(/[a-z]/i) || previousChar.match(/[0-9]/)))\nif(_this.isSpecialChar(previousChar)){begining=index;break;}}}}var end;//in case of automatic space added by clicking\nif(rightIndex!==leftIndex&&_this.isSpecialChar(textParagraph[rightIndex-1])){end=rightIndex-1;}else if(rightIndex===textParagraph.length){// If the last chracter is in the end of a chunk.\nend=rightIndex;}else{for(var _index=rightIndex;_index<=textParagraph.length;_index++){// If we reached the end of the paragraph.\nif(_index===textParagraph.length){end=_index;// If we reached a white space.\n}else{var nextChar=textParagraph[_index];if(_this.isSpecialChar(nextChar)){end=_index;break;}}}}return[begining,end];};_this.clacOfsetFromTheStartOfTheText=function(text,line,paragraph){//calculate the offset from the beggining of the text\n// Calc the number of letter in the previous lines.\nvar offset=0;// Add the number of new line character to the offset\noffset+=line;// Go through the text lines.\nfor(var i=0;i<=line;i++){// Go through the partition of the line.\n// If the line is the line where the highlighted text is in, run until\n// the part where the highlighted text is found.\nvar end=text[i].length;if(i===line){end=paragraph;}for(var j=0;j<end;j++){// In case the current part does not contain highlighted text.\nif(!text[i][j].startsWith(\"%\")){offset+=text[i][j].length;}// In case the current part contains highlighted text.\nelse{var currentPartText=text[i][j].split(\"%\");var tagLength=currentPartText[1].length;var textlength=currentPartText[2].length;// 2 * tagLength + 5:\n// 2 * tagLength: stands for the 2 appearance of the tag's name, at the text.\n// (One appearance of the tag in the opening tag and the second in the closing tag).\n// 5: stands for the characters : <> </>, <> appear in the opening tag,\n// and </> in the closing tag.\noffset+=textlength+2*tagLength+5;}}}return offset;// Add to the calculted offset the highlighted text offset from the beginng of it's part\n// in the line the text is found.\n//.offset += leftBorder;\n};_this.setPreInAndAfterHighlightedText=function(formatedText,line,paragraph,borders,offset){var preTag;var inTag;var postTag;var fileContent=_this.props.fileContent;// If the highlited text is not already tagged.\nif(formatedText[line][paragraph][0]!==\"%\"){preTag=fileContent.substring(0,borders[0]);inTag=fileContent.substring(borders[0],borders[1]);postTag=fileContent.substring(borders[1],fileContent.length);_this.state.isHighlightedTextTagged=false;}// The highlighted text is surrounded by a tag. \nelse{var textParagraph=formatedText[line][paragraph].split(\"%\");var tagLength=textParagraph[1].length;preTag=fileContent.substring(0,offset);inTag=fileContent.substring(offset+tagLength+2,offset+tagLength+2+textParagraph[2].length);postTag=fileContent.substring(offset+textParagraph[2].length+2*tagLength+5,fileContent.length);_this.state.isHighlightedTextTagged=true;}_this.state.preHighlightedText=preTag;_this.state.highlightedText=inTag;_this.setState({postHighlightedText:postTag});};_this.render=function(){var page=/*#__PURE__*/React.createElement(\"div\",null,/*#__PURE__*/React.createElement(\"table\",{length:\"100%\"},/*#__PURE__*/React.createElement(\"tr\",{length:\"100%\"},/*#__PURE__*/React.createElement(\"td\",{length:\"25%\"},\" \"),/*#__PURE__*/React.createElement(\"td\",{length:\"50%\"},\" \",/*#__PURE__*/React.createElement(ContextMenuTrigger,{id:\"context_menu_trigger\"},/*#__PURE__*/React.createElement(\"div\",{id:\"text\",onClickCapture:_this.captureHighlightedText,style:{backgroundColor:\"white\",borderStyle:\"solid\",height:\"8cm\",width:\"30cm\",overflowY:\"scroll\",overflowX:\"hidden\"}},_this.setTags(_this.props.fileContent)),\" \"),/*#__PURE__*/React.createElement(ContextMenu,{id:\"context_menu_trigger\"},_this.createMenu())),/*#__PURE__*/React.createElement(\"td\",{length:\"25%\"},\" \"))));return page;};_this.createMenu=function(){var menu;if(_this.state.isHighlightedTextTagged===false){menu=_this.props.tagsList.map(function(part,i){return/*#__PURE__*/React.createElement(MenuItem,{key:i,id:part,onClick:_this.addTag},\" \",/*#__PURE__*/React.createElement(\"div\",{id:part,style:{backgroundColor:\"white\"}},\"Set as \",part,\" \"));});}else{menu=/*#__PURE__*/React.createElement(MenuItem,{id:\"no_tag\",onClick:_this.addTag},\" \",/*#__PURE__*/React.createElement(\"div\",{id:\"no_tag\",style:{backgroundColor:\"white\"}},\"Remove tag\",\" \"));}return menu;};return _this;}return taggedTextArea;}(Component);export default taggedTextArea;","map":{"version":3,"sources":["C:/Users/Yifat/finalProject/text-tagging/src/components/taggedTextArea.jsx"],"names":["React","Component","ContextMenu","MenuItem","ContextMenuTrigger","taggedTextArea","state","preHighlightedText","highlightedText","postHighlightedText","preHtmlFormatedText","isHighlightedTextTagged","isSpecialChar","character","i","props","specialCharsList","length","setTags","fileContent","text","regexIsSpace","RegExp","lines","split","convertedLine","convertedLines","htmlFormLines","index","separateTaggedFromUntaggedText","push","makeHtmlForm","htmlForm","map","line","higlight","regexIstag","regexIsCloseTag","formattedparts","parts","test","currenttag","substring","regexIsSearchedTag","serchingIndex","currentTaggedText","copyingIndex","lineNumber","regexIsTagged","part","fontWeight","backgroundColor","tagsAndColors","reverse","addTag","event","data","tagName","window","getSelection","anchorNode","parentElement","id","updateFileContent","captureHighlightedText","isNaN","base","baseOffset","extent","extentOffset","formatedText","lineAndparagraph","parseInt","paragraph","borders","calcBordersOfHighlightedText","extendHighlightToEntireWord","offset","clacOfsetFromTheStartOfTheText","setPreInAndAfterHighlightedText","leftBorder","rightBorder","leftIndex","rightIndex","textParagraph","begining","previousChar","end","nextChar","j","startsWith","currentPartText","tagLength","textlength","preTag","inTag","postTag","setState","render","page","borderStyle","height","width","overflowY","overflowX","createMenu","menu","tagsList"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\r\nimport { ContextMenu, MenuItem, ContextMenuTrigger } from \"react-contextmenu\";\r\n\r\n\r\nclass taggedTextArea extends Component {\r\n  state = {\r\n    // Used to keep the text the user marked\r\n    preHighlightedText: \"\",\r\n    highlightedText: \"\",\r\n    postHighlightedText: \"\",\r\n\r\n    preHtmlFormatedText: [],\r\n\r\n    isHighlightedTextTagged: false,\r\n    //isUpTodate: true,\r\n  };\r\n\r\n  // This function gets a character and returns if the character \r\n  // is in the application's special characters' list.\r\n  isSpecialChar = (character) => {\r\n    for (let i = 0; i < this.props.specialCharsList.length; i++) {\r\n      if (this.props.specialCharsList[i] === character) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  };\r\n\r\n  // This funtiuos reads the clean text (with the tags), and turns it to the\r\n  // form which the text is representd to the user.\r\n  // separateTaggedFromUntaggedText\r\n  setTags = () => {\r\n    if (this.props.fileContent === \"\") {\r\n      return;\r\n    }\r\n\r\n    // Separate the text in to lines.\r\n    let text = this.props.fileContent;\r\n    let regexIsSpace = RegExp(\"\\n\");\r\n    let lines = text.split(regexIsSpace);\r\n\r\n    // Work on each line seperately.\r\n    // Convert every line to a format that later will be converted,\r\n    // to an html format.\r\n    let convertedLine = \"\";\r\n    let convertedLines = [];\r\n    let htmlFormLines = [];\r\n    for (let index = 0; index < lines.length; index++) {\r\n      convertedLine = this.separateTaggedFromUntaggedText(lines[index]);\r\n      convertedLines.push(convertedLine);\r\n      htmlFormLines.push(this.makeHtmlForm(index, convertedLine));\r\n    }\r\n\r\n    this.state.preHtmlFormatedText = convertedLines;\r\n\r\n    // Add a break after each line.\r\n    let htmlForm = (\r\n      <React.Fragment>\r\n        {htmlFormLines.map((line, i) => (\r\n          <span key={i} id={i}>\r\n            {line}\r\n            <br />\r\n          </span>\r\n        ))}\r\n        <br />\r\n      </React.Fragment>\r\n    );\r\n\r\n    return htmlForm;\r\n  };\r\n\r\n  // This funtions detects the tags that appear in the text.\r\n  // After the detection, the function separates the text to parts.\r\n  // Each part contains a segment of the text and the tag that surrounds it\r\n  // (if the sedment is surrounded by a tag).\r\n  separateTaggedFromUntaggedText = (text) => {\r\n    let higlight = \"<[^<]+>\";\r\n    let regexIstag = RegExp(higlight);\r\n    let regexIsCloseTag = RegExp(\"</[^<]+>\");\r\n    let formattedparts = [];\r\n\r\n    // Seperates plain text from tags.\r\n    let parts = text.split(new RegExp(`(${higlight})`, \"gi\"));\r\n\r\n    // Handle each part.\r\n    for (let index = 0; index < parts.length; index++) {\r\n      // If the tag is a plain text.\r\n      // (or a closing tag without an opening tag matches it).\r\n      if (\r\n        (!regexIstag.test(parts[index]) && parts[index] !== \"\") ||\r\n        regexIsCloseTag.test(parts[index])\r\n      ) {\r\n        // Add the text to the proccesd text.\r\n        formattedparts.push(parts[index]);\r\n      }\r\n      // If the tag is an open tag.\r\n      else if (\r\n        regexIstag.test(parts[index]) &&\r\n        !regexIsCloseTag.test(parts[index])\r\n      ) {\r\n        // Create a regex that checks for the closer tag matches the current tag.\r\n        let currenttag = parts[index].substring(1, parts[index].length - 1);\r\n        let regexIsSearchedTag = RegExp(\"</\" + currenttag + \">\");\r\n\r\n        // Search the closer tag matches the currnt tag.\r\n        let serchingIndex = index + 1;\r\n        while (\r\n          !regexIsSearchedTag.test(parts[serchingIndex]) &&\r\n          serchingIndex < parts.length\r\n        ) {\r\n          serchingIndex++;\r\n        }\r\n\r\n        // If a matching closer tag was not found.\r\n        if (serchingIndex >= parts.length) {\r\n          // Consider the tag as a plain text.\r\n          // Add the text to the proccesd text.\r\n          formattedparts.push(parts[index]);\r\n        }\r\n        // If a matching closer tag was found.\r\n        else {\r\n          // Make a string contains all the plain text surrounded by the tag.\r\n          let currentTaggedText = \"\";\r\n          for (\r\n            let copyingIndex = index + 1;\r\n            copyingIndex < serchingIndex;\r\n            copyingIndex++\r\n          ) {\r\n            currentTaggedText += parts[copyingIndex];\r\n          }\r\n\r\n          // Add the text to the proccesd text, with a prefix that tells the tag name.\r\n          formattedparts.push(\"%\" + currenttag + \"%\" + currentTaggedText);\r\n          index = serchingIndex;\r\n        }\r\n      }\r\n    }\r\n\r\n    return formattedparts;\r\n  };\r\n\r\n  // The function gets a line from the text, (after the tags detection performed\r\n  // in separateTaggedFromUntaggedText), and make an html representation of the line. \r\n  makeHtmlForm = (lineNumber, line) => {\r\n    let regexIsTagged = RegExp(\"%.+%.+\");\r\n    let htmlForm = (\r\n      <React.Fragment>\r\n        {\" \"}\r\n        {line.map((part, i) => (\r\n          <span\r\n            key={lineNumber + \",\" + i}\r\n            id={lineNumber + \",\" + i}\r\n            style={\r\n              regexIsTagged.test(part)\r\n                ?\r\n                  {\r\n                    fontWeight: \"bold\",\r\n                    backgroundColor: this.props.tagsAndColors[\r\n                      part.split(\"%\")[1]\r\n                    ],\r\n                  }\r\n                : {}\r\n            }\r\n          >\r\n            {part.split(\"%\").reverse()[0]}\r\n          </span>\r\n        ))}\r\n      </React.Fragment>\r\n    );\r\n\r\n    return htmlForm;\r\n  };\r\n\r\n  // When a user Highlights text segment and choose to tag that segment,\r\n  // this function is called.\r\n  // Tthe funtion update the whole text so the highlight segment will be\r\n  // serroiunded by a tag.\r\n  addTag = (event, data) => {\r\n    if (this.state.highlightedText === \"\"){\r\n      return;\r\n    }\r\n    //this.state.isUpTodate = false;\r\n    let tagName = window.getSelection().anchorNode.parentElement.id;\r\n    let text;\r\n    if (tagName !== \"no_tag\") {\r\n      text =\r\n        this.state.preHighlightedText +\r\n        \"<\" +\r\n        tagName +\r\n        \">\" +\r\n        this.state.highlightedText +\r\n        \"</\" +\r\n        tagName +\r\n        \">\" +\r\n        this.state.postHighlightedText;\r\n    } else {\r\n      text =\r\n        this.state.preHighlightedText +\r\n        this.state.highlightedText +\r\n        this.state.postHighlightedText;\r\n    }\r\n\r\n    this.state.preHighlightedText = \"\";\r\n    this.state.higlight = \"\";\r\n    this.state.postHighlightedText = \"\";\r\n\r\n    this.props.updateFileContent(text);\r\n  };\r\n\r\n  // Recognise the text the user Highlights, and the text segments that\r\n  // comes before and after the Highlighted text.\r\n  captureHighlightedText = (event, data) => {\r\n    if (isNaN(window.getSelection())) {\r\n      return;\r\n    }\r\n\r\n    let base = window.getSelection().baseOffset;\r\n    let extent = window.getSelection().extentOffset;\r\n    let formatedText = this.state.preHtmlFormatedText;\r\n\r\n    // Get the lines number and part number the highlited text is in.\r\n    let lineAndparagraph = window.getSelection().anchorNode.parentElement.id;\r\n    lineAndparagraph = lineAndparagraph.split(\",\");\r\n    let line = parseInt(lineAndparagraph[0]);\r\n    let paragraph = parseInt(lineAndparagraph[1]);\r\n    \r\n    // If the highlighted text is not valid.\r\n    if(isNaN(line) || isNaN(paragraph)) {\r\n      return;\r\n    }\r\n\r\n    let borders = this.calcBordersOfHighlightedText(base, extent);\r\n    borders = this.extendHighlightToEntireWord(\r\n      formatedText,\r\n      line,\r\n      paragraph,\r\n      borders[0],\r\n      borders[1]\r\n    );\r\n\r\n    let offset = this.clacOfsetFromTheStartOfTheText(\r\n      formatedText,\r\n      line,\r\n      paragraph\r\n    );\r\n\r\n    borders[0] += offset;\r\n    borders[1] += offset;\r\n\r\n    this.setPreInAndAfterHighlightedText(formatedText, line, paragraph, borders, offset)\r\n  };\r\n\r\n  // calculate and return the start index and the end index of the highlighted text\r\n  calcBordersOfHighlightedText = (base, extent) => {\r\n    let leftBorder;\r\n    let rightBorder;\r\n\r\n    if (base <= extent) {\r\n      leftBorder = base;\r\n      rightBorder = extent;\r\n    } else if (base > extent) {\r\n      leftBorder = extent;\r\n      rightBorder = base;\r\n    }\r\n\r\n    return [leftBorder, rightBorder];\r\n  };\r\n\r\n\r\n  //Returns the start index and the end index of the word that contains highligted letters.\r\n  extendHighlightToEntireWord = (\r\n    text,\r\n    line,\r\n    paragraph,\r\n    leftIndex,\r\n    rightIndex\r\n  ) => {\r\n    let textParagraph = text[line][paragraph];\r\n\r\n    // Sreaching for the begining of the highlighted word.\r\n    let begining;\r\n    // If the first chracter is in a begining of a chunk.\r\n    if (leftIndex === 0) {\r\n      begining = leftIndex;\r\n    } else {\r\n      for (let index = leftIndex; index >= 0; index--) {\r\n        // we reached the begining of the current paragraph.\r\n        if (index === 0) {\r\n          begining = index;\r\n          // If we reached a space character.\r\n        } else {\r\n          let previousChar = textParagraph[index - 1];\r\n          //(!(previousChar.match(/[a-z]/i) || previousChar.match(/[0-9]/)))\r\n          if (this.isSpecialChar(previousChar)) {\r\n            begining = index;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    let end;\r\n    //in case of automatic space added by clicking\r\n    if (\r\n      rightIndex !== leftIndex &&\r\n      this.isSpecialChar(textParagraph[rightIndex - 1])\r\n    ) {\r\n      end = rightIndex - 1;\r\n    } else if (rightIndex === textParagraph.length) {\r\n      // If the last chracter is in the end of a chunk.\r\n      end = rightIndex;\r\n    } else {\r\n      for (let index = rightIndex; index <= textParagraph.length; index++) {\r\n        // If we reached the end of the paragraph.\r\n        if (index === textParagraph.length) {\r\n          end = index;\r\n          // If we reached a white space.\r\n        } else {\r\n          let nextChar = textParagraph[index];\r\n          if (this.isSpecialChar(nextChar)) {\r\n            end = index;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return [begining, end];\r\n  };\r\n\r\n  // Calculating the absolute index of the start of the text\r\n  clacOfsetFromTheStartOfTheText = (text, line, paragraph) => {\r\n    //calculate the offset from the beggining of the text\r\n    // Calc the number of letter in the previous lines.\r\n    let offset = 0;\r\n\r\n    // Add the number of new line character to the offset\r\n    offset += line;\r\n\r\n    // Go through the text lines.\r\n    for (let i = 0; i <= line; i++) {\r\n      // Go through the partition of the line.\r\n      // If the line is the line where the highlighted text is in, run until\r\n      // the part where the highlighted text is found.\r\n      let end = text[i].length;\r\n      if (i === line) {\r\n        end = paragraph;\r\n      }\r\n      for (let j = 0; j < end; j++) {\r\n        // In case the current part does not contain highlighted text.\r\n        if (!text[i][j].startsWith(\"%\")) {\r\n          offset += text[i][j].length;\r\n        }\r\n        // In case the current part contains highlighted text.\r\n        else {\r\n          let currentPartText = text[i][j].split(\"%\");\r\n          let tagLength = currentPartText[1].length;\r\n          let textlength = currentPartText[2].length;\r\n          // 2 * tagLength + 5:\r\n          // 2 * tagLength: stands for the 2 appearance of the tag's name, at the text.\r\n          // (One appearance of the tag in the opening tag and the second in the closing tag).\r\n          // 5: stands for the characters : <> </>, <> appear in the opening tag,\r\n          // and </> in the closing tag.\r\n          offset += textlength + 2 * tagLength + 5;\r\n        }\r\n      }\r\n    }\r\n\r\n    return offset;\r\n\r\n    // Add to the calculted offset the highlighted text offset from the beginng of it's part\r\n    // in the line the text is found.\r\n    //.offset += leftBorder;\r\n  };\r\n\r\n  //cuts the highlighted text by saving 3 strings. the text before the highlighted\r\n  //text, the highlighted text and the text after the highlighted text  \r\n  setPreInAndAfterHighlightedText = (formatedText, line, paragraph, borders, offset) =>{\r\n    let preTag;\r\n    let inTag;\r\n    let postTag;\r\n\r\n    let fileContent = this.props.fileContent;\r\n\r\n    // If the highlited text is not already tagged.\r\n    if (formatedText[line][paragraph][0] !== \"%\") {\r\n      preTag = fileContent.substring(0, borders[0]);\r\n      inTag = fileContent.substring(borders[0], borders[1]);\r\n      postTag = fileContent.substring(borders[1], fileContent.length);\r\n      this.state.isHighlightedTextTagged = false;\r\n    }\r\n    // The highlighted text is surrounded by a tag. \r\n    else {\r\n      let textParagraph = formatedText[line][paragraph].split(\"%\");\r\n      let tagLength = textParagraph[1].length;\r\n      preTag = fileContent.substring(0, offset);\r\n      inTag = fileContent.substring(\r\n        offset + tagLength + 2,\r\n        offset + tagLength + 2 + textParagraph[2].length\r\n      );\r\n      postTag = fileContent.substring(\r\n        offset + textParagraph[2].length + 2 * tagLength + 5,\r\n        fileContent.length\r\n      );\r\n      this.state.isHighlightedTextTagged = true;\r\n    }\r\n\r\n    this.state.preHighlightedText = preTag;\r\n    this.state.highlightedText = inTag;\r\n    this.setState({ postHighlightedText: postTag });\r\n  };\r\n\r\n  render = () => {\r\n    let page = (\r\n      <div>\r\n        <table length=\"100%\">\r\n          <tr length=\"100%\">\r\n            <td length=\"25%\"> </td>\r\n            <td length=\"50%\">\r\n              {\" \"}\r\n              <ContextMenuTrigger id=\"context_menu_trigger\">\r\n                <div\r\n                  id=\"text\"\r\n                  onClickCapture={this.captureHighlightedText}\r\n                  style={{\r\n                    backgroundColor: \"white\",\r\n                    borderStyle: \"solid\",\r\n                    height: \"8cm\",\r\n                    width: \"30cm\",\r\n                    overflowY: \"scroll\",\r\n                    overflowX: \"hidden\",\r\n                  }}\r\n                >\r\n                  {this.setTags(this.props.fileContent)}\r\n                </div>{\" \"}\r\n              </ContextMenuTrigger>\r\n              <ContextMenu id=\"context_menu_trigger\">\r\n                {this.createMenu()}\r\n              </ContextMenu>\r\n            </td>\r\n            <td length=\"25%\"> </td>\r\n          </tr>\r\n        </table>\r\n      </div>\r\n    );\r\n    return page;\r\n  };\r\n\r\n  // Creates a menu that appears when the user press the right click.\r\n  // Creates only the menu items and not the menu itself.\r\n  // The menu created depends on the value of this.state.isHighlightedTextTagged\r\n  // that dends on the valye of this.state.highlightedText\r\n  // If the highlighted text is not serrounded by a tag, the menu contains\r\n  // all the tags avaliable, and if not, the menu contains only the option\r\n  // \"remove tag:.\r\n  createMenu = () => {\r\n    let menu;\r\n    if (this.state.isHighlightedTextTagged === false) {\r\n      menu = this.props.tagsList.map((part, i) => (\r\n        <MenuItem key={i} id={part} onClick={this.addTag}>\r\n          {\" \"}\r\n          <div id={part} style={{ backgroundColor: \"white\" }}>\r\n            Set as {part}{\" \"}\r\n          </div>\r\n        </MenuItem>\r\n      ));\r\n    } else {\r\n      menu = (\r\n        <MenuItem id=\"no_tag\" onClick={this.addTag}>\r\n          {\" \"}\r\n          <div id=\"no_tag\" style={{ backgroundColor: \"white\" }}>\r\n            Remove tag{\" \"}\r\n          </div>\r\n        </MenuItem>\r\n      );\r\n    }\r\n    return menu;\r\n  };\r\n}\r\n\r\nexport default taggedTextArea;\r\n"]},"metadata":{},"sourceType":"module"}